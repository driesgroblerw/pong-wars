<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pong wars | Koen van Gilst</title>
  <meta name="description"
    content="The eternal battle between day and night, good and bad. Written in JavaScript with some HTML & CSS in one index.html. Feel free to reuse the code and create your own version." />
  <link rel="canonical" href="https://pong-wars.koenvangilst.nl/" />
  <link rel="author" href="https://koenvangilst.nl" />
  <meta name="theme-color" content="#172B36" />
  <meta name="creator" content="Koen van Gilst" />
  <script defer data-domain="pong-wars.koenvangilst.nl" src="https://plausible.koenvangilst.nl/js/script.js"></script>
  <style>
    html {
      height: 100%;
    }

    body {
      height: 100%;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(to bottom, #172b36 0%, #d9e8e3 100%);
    }

    #container {
      display: flex;
      align-items: center;
      flex-direction: column;
      width: min(80vh, 80%);
      max-width: 600px;
      height: 100%;
    }

    /* Top bar used to house controls in fullscreen and normal mode */
    #topBar {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
      padding: 8px 12px;
      box-sizing: border-box;
    }

    /* Modern button styles */
    button {
      appearance: none;
      -webkit-appearance: none;
      border: none;
      background: linear-gradient(180deg, #ffffff 0%, #f3f4f6 100%);
      color: #172b36;
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(16,24,40,0.06), inset 0 -1px 0 rgba(255,255,255,0.6);
      cursor: pointer;
      font-family: monospace;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 18px rgba(16,24,40,0.08);
    }
    button:active {
      transform: translateY(0);
      box-shadow: 0 3px 8px rgba(16,24,40,0.06);
    }
    button:focus {
      outline: 2px solid rgba(33,150,243,0.18);
      outline-offset: 2px;
    }
    input[type="range"] { height: 28px; }
    input[type="color"] { width: 36px; height: 28px; border-radius: 6px; border: none; padding:0; }

    /* When container is fullscreen we want a fixed top bar */
    .fs-topbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 9999;
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(6px);
      padding: 8px 12px;
    }

    canvas {
      display: block;
      border-radius: 4px;
      overflow: hidden;
      width: 100%;
      margin-top: auto;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
    }

    /* Full-bleed canvas when fullscreen: remove border radius and shadow */
    .fs-canvas {
      width: 100vw !important;
      height: 100vh !important;
      border-radius: 0 !important;
      box-shadow: none !important;
    }

    #score {
      font-family: monospace;
      margin-top: 30px;
      font-size: 16px;
      padding-left: 20px;
      color: #172b36;
    }

    #made {
      text-align: center;
      line-height: 1.5;
      font-family: monospace;
      margin-top: auto;
      margin-bottom: 20px;
      font-size: 10px;
    }

    #made a {
      color: #172b36;
    }
  </style>
</head>

<body>
  <div id="container">
    <div id="topBar">
      <div id="controls" style="display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:center;">
        <div style="display:flex; gap:6px; align-items:center;">
          <button id="speedDown" type="button">- Speed</button>
          <button id="speedUp" type="button">+ Speed</button>
        </div>
        <label style="display:flex; gap:6px; align-items:center;">
          <input id="effectsToggle" type="checkbox" checked>
          Effects
        </label>
        <label style="display:flex; gap:8px; align-items:center;">
          Block size
          <input id="blockSize" type="range" min="4" max="40" value="10">
        </label>
        <label style="display:flex; gap:8px; align-items:center;">
          Day
          <input id="dayColor" type="color" value="#D9E8E3">
        </label>
        <label style="display:flex; gap:8px; align-items:center;">
          Night
          <input id="nightColor" type="color" value="#172B36">
        </label>
  <button id="pauseBtn" type="button">Pause</button>
  <button id="resetBtn" type="button">Reset</button>
  <button id="fullscreenBtn" type="button">Toggle fullscreen</button>
      </div>
    </div>
    <canvas id="pongCanvas" width="600" height="600"></canvas>
    <div id="score"></div>
    <p id="made">
      made by
      <a href="https://koenvangilst.nl/labs/pong-wars">Koen van Gilst</a> | source on
      <a href="https://github.com/vnglst/pong-wars">github</a>
    </p>
  </div>
</body>

<script>
  // Source palette: https://twitter.com/AlexCristache/status/1738610343499157872
  // Idea for Pong wars: https://twitter.com/nicolasdnl/status/1749715070928433161

  const colorPalette = {
    ArcticPowder: "#F1F6F4",
    MysticMint: "#D9E8E3",
    Forsythia: "#FFC801",
    DeepSaffron: "#FF9932",
    NocturnalExpedition: "#114C5A",
    OceanicNoir: "#172B36",
  };

  // Ripples for collision after-effects (timed, easing, fill)
  const ripples = [];
  let showEffects = true;

  function createRipple(x, y, color) {
    if (!showEffects) return;
    const startR = Math.max(4, (typeof SQUARE_SIZE === 'number' ? SQUARE_SIZE : 10) / 2);
    const maxR = Math.max(24, (typeof SQUARE_SIZE === 'number' ? SQUARE_SIZE : 10) * 6);
    const duration = 600 + Math.random() * 300; // milliseconds
    ripples.push({ x, y, startR, maxR, duration, elapsed: 0, color });
    if (ripples.length > 300) ripples.shift();
  }

  // Helper: hex color to rgba string with alpha
  function hexWithAlpha(hex, alpha) {
    if (!hex) return `rgba(255,255,255,${alpha})`;
    const trimmed = hex.replace('#', '');
    const bigint = parseInt(trimmed, 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return `rgba(${r},${g},${b},${alpha})`;
  }

  const canvas = document.getElementById("pongCanvas");
  const ctx = canvas.getContext("2d");
  const fullscreenBtn = document.getElementById("fullscreenBtn");
  const scoreElement = document.getElementById("score");
  const speedUpBtn = document.getElementById('speedUp');
  const speedDownBtn = document.getElementById('speedDown');
  const blockSizeInput = document.getElementById('blockSize');
  const dayColorInput = document.getElementById('dayColor');
  const nightColorInput = document.getElementById('nightColor');
  const container = document.getElementById('container');
  const controlsEl = document.getElementById('controls');

  let DAY_COLOR = colorPalette.MysticMint;
  let DAY_BALL_COLOR = colorPalette.NocturnalExpedition;
  let NIGHT_COLOR = colorPalette.NocturnalExpedition;
  let NIGHT_BALL_COLOR = colorPalette.MysticMint;
  let SQUARE_SIZE = 10;
  const MIN_SPEED = 5;
  const MAX_SPEED = 10;

  // device pixel ratio and logical (CSS) canvas size
  let dpr = Math.max(1, window.devicePixelRatio || 1);
  let logicalWidth = Math.floor(canvas.width / dpr) || 600;
  let logicalHeight = Math.floor(canvas.height / dpr) || 600;

  // numSquares depend on current logical (CSS) canvas size and are recalculated on resize
  let numSquaresX = Math.floor(logicalWidth / SQUARE_SIZE);
  let numSquaresY = Math.floor(logicalHeight / SQUARE_SIZE);

  let dayScore = 0;
  let nightScore = 0;

  let squares = [];

  function initializeSquares() {
    numSquaresX = Math.max(2, Math.floor(logicalWidth / SQUARE_SIZE));
    numSquaresY = Math.max(2, Math.floor(logicalHeight / SQUARE_SIZE));
    squares = [];
    for (let i = 0; i < numSquaresX; i++) {
      squares[i] = [];
      for (let j = 0; j < numSquaresY; j++) {
        squares[i][j] = i < numSquaresX / 2 ? DAY_COLOR : NIGHT_COLOR;
      }
    }
  }

  const balls = [
    {
      x: logicalWidth / 4,
      y: logicalHeight / 2,
      dx: 8,
      dy: -8,
      reverseColor: DAY_COLOR,
      ballColor: DAY_BALL_COLOR,
    },
    {
      x: (logicalWidth / 4) * 3,
      y: logicalHeight / 2,
      dx: -8,
      dy: 8,
      reverseColor: NIGHT_COLOR,
      ballColor: NIGHT_BALL_COLOR,
    },
  ];

  function resizeCanvas(scaleBalls = true) {
    const oldWidth = canvas.width || 600;
    const oldHeight = canvas.height || 600;

    // desired CSS size (logical pixels)
    let cssWidth, cssHeight;
    if (document.fullscreenElement) {
      cssWidth = window.innerWidth;
      const topBar = document.getElementById('topBar');
      const topH = topBar ? topBar.clientHeight : 0;
      cssHeight = Math.max(100, window.innerHeight - topH);
    } else {
      cssWidth = Math.floor(canvas.clientWidth || 600);
      cssHeight = Math.floor(canvas.clientWidth || 600);
    }

    // update global dpr and logical sizes
    dpr = Math.max(1, window.devicePixelRatio || 1);
    logicalWidth = cssWidth;
    logicalHeight = cssHeight;

    // set canvas pixel dimensions and scale context
    canvas.style.width = logicalWidth + 'px';
    canvas.style.height = logicalHeight + 'px';
    canvas.width = Math.floor(logicalWidth * dpr);
    canvas.height = Math.floor(logicalHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Scale ball positions proportionally to new logical size to avoid jumps
    if (scaleBalls && oldWidth && oldHeight) {
      const oldLogicalW = Math.floor(oldWidth / (window.devicePixelRatio || 1));
      const oldLogicalH = Math.floor(oldHeight / (window.devicePixelRatio || 1));
      const scaleX = logicalWidth / (oldLogicalW || logicalWidth);
      const scaleY = logicalHeight / (oldLogicalH || logicalHeight);
      balls.forEach((b) => {
        b.x = b.x * scaleX;
        b.y = b.y * scaleY;
      });
    }

    initializeSquares();
  }

  // Update squares colors from current color variables
  function applyColorsToSquares() {
    for (let i = 0; i < numSquaresX; i++) {
      for (let j = 0; j < numSquaresY; j++) {
        squares[i][j] = i < numSquaresX / 2 ? DAY_COLOR : NIGHT_COLOR;
      }
    }
    // update ball colors
    if (balls[0]) balls[0].ballColor = DAY_BALL_COLOR;
    if (balls[1]) balls[1].ballColor = NIGHT_BALL_COLOR;
  }

  let iteration = 0;
  let paused = false;

  function drawBall(ball) {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, SQUARE_SIZE / 2, 0, Math.PI * 2, false);
    ctx.fillStyle = ball.ballColor;
    ctx.fill();
    ctx.closePath();
  }

  function drawSquares() {
    dayScore = 0;
    nightScore = 0;

    for (let i = 0; i < numSquaresX; i++) {
      for (let j = 0; j < numSquaresY; j++) {
        ctx.fillStyle = squares[i][j];
        ctx.fillRect(i * SQUARE_SIZE, j * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);

        // Update scores
        if (squares[i][j] === DAY_COLOR) dayScore++;
        if (squares[i][j] === NIGHT_COLOR) nightScore++;
      }
    }
  }

  function checkSquareCollision(ball) {
    // Check multiple points around the ball's circumference
    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
      const checkX = ball.x + Math.cos(angle) * (SQUARE_SIZE / 2);
      const checkY = ball.y + Math.sin(angle) * (SQUARE_SIZE / 2);

      const i = Math.floor(checkX / SQUARE_SIZE);
      const j = Math.floor(checkY / SQUARE_SIZE);

      if (i >= 0 && i < numSquaresX && j >= 0 && j < numSquaresY) {
        if (squares[i][j] !== ball.reverseColor) {
          // Square hit! Update square color
          squares[i][j] = ball.reverseColor;

          // Determine bounce direction based on the angle
          if (Math.abs(Math.cos(angle)) > Math.abs(Math.sin(angle))) {
            ball.dx = -ball.dx;
            createRipple(ball.x, ball.y, ball.ballColor);
          } else {
            ball.dy = -ball.dy;
            createRipple(ball.x, ball.y, ball.ballColor);
          }
        }
      }
    }
  }

  function checkBoundaryCollision(ball) {
    if (ball.x + ball.dx > logicalWidth - SQUARE_SIZE / 2 || ball.x + ball.dx < SQUARE_SIZE / 2) {
      ball.dx = -ball.dx;
      createRipple(ball.x, ball.y, ball.ballColor);
    }
    if (ball.y + ball.dy > logicalHeight - SQUARE_SIZE / 2 || ball.y + ball.dy < SQUARE_SIZE / 2) {
      ball.dy = -ball.dy;
      createRipple(ball.x, ball.y, ball.ballColor);
    }
  }

  function addRandomness(ball) {
    ball.dx += Math.random() * 0.02 - 0.01;
    ball.dy += Math.random() * 0.02 - 0.01;

    // Limit the speed of the ball
    ball.dx = Math.min(Math.max(ball.dx, -MAX_SPEED), MAX_SPEED);
    ball.dy = Math.min(Math.max(ball.dy, -MAX_SPEED), MAX_SPEED);

    // Make sure the ball always maintains a minimum speed
    if (Math.abs(ball.dx) < MIN_SPEED) ball.dx = ball.dx > 0 ? MIN_SPEED : -MIN_SPEED;
    if (Math.abs(ball.dy) < MIN_SPEED) ball.dy = ball.dy > 0 ? MIN_SPEED : -MIN_SPEED;
  }

  function draw() {
    ctx.clearRect(0, 0, logicalWidth, logicalHeight);
    if (paused) {
      // still draw existing scene but don't update game state; show overlay
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(0, 0, logicalWidth, logicalHeight);
      ctx.fillStyle = '#fff';
      ctx.font = '28px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('PAUSED', logicalWidth / 2, logicalHeight / 2);
      return;
    }
    drawSquares();

    scoreElement.textContent = `day ${dayScore} | night ${nightScore}`;

    balls.forEach((ball) => {
      drawBall(ball);
      checkSquareCollision(ball);
      checkBoundaryCollision(ball);
      ball.x += ball.dx;
      ball.y += ball.dy;

      addRandomness(ball);
    });

    // Update and draw ripples (timed filled radial gradients with easing)
    for (let i = ripples.length - 1; i >= 0; i--) {
      const p = ripples[i];
      // time progression (approx based on frame rate)
      p.elapsed += 1000 / FRAME_RATE;
      const t = Math.min(1, p.elapsed / p.duration);
      const e = 1 - Math.pow(1 - t, 3); // easeOutCubic
      const r = p.startR + (p.maxR - p.startR) * e;

      // build gradient
      const grad = ctx.createRadialGradient(p.x, p.y, Math.max(1, r * 0.05), p.x, p.y, r);
      grad.addColorStop(0, hexWithAlpha(p.color || '#ffffff', 0.6 * (1 - e)));
      grad.addColorStop(1, hexWithAlpha(p.color || '#ffffff', 0));
      ctx.beginPath();
      ctx.fillStyle = grad;
      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.closePath();

      if (t >= 1) ripples.splice(i, 1);
    }

    iteration++;
    if (iteration % 1_000 === 0) console.log("iteration", iteration);
  }

  const FRAME_RATE = 100;
  setInterval(draw, 1000 / FRAME_RATE);

  // Fullscreen toggle and resize handling
  function toggleFullscreen() {
    if (!document.fullscreenElement) {
      const target = document.documentElement || container;
      if (target.requestFullscreen) {
        target.requestFullscreen();
      } else if (target.webkitRequestFullscreen) {
        target.webkitRequestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      }
    }
  }

  // When fullscreen state changes, update UI and resize the canvas
  document.addEventListener('fullscreenchange', () => {
    const isFs = !!document.fullscreenElement;
    const topBar = document.getElementById('topBar');
    if (isFs) {
      if (topBar) topBar.classList.add('fs-topbar');
      canvas.classList.add('fs-canvas');
    } else {
      if (topBar) topBar.classList.remove('fs-topbar');
      canvas.classList.remove('fs-canvas');
    }
    resizeCanvas(true);
  });

  // Resize when the window changes size (not in fullscreen)
  window.addEventListener('resize', () => resizeCanvas(true));

  // Double click canvas to toggle fullscreen
  canvas.addEventListener('dblclick', toggleFullscreen);
  fullscreenBtn.addEventListener('click', toggleFullscreen);
  // Speed controls: increase/decrease velocities by 10%
  if (speedUpBtn) speedUpBtn.addEventListener('click', () => {
    balls.forEach(b => {
      b.dx *= 1.1;
      b.dy *= 1.1;
    });
  });
  if (speedDownBtn) speedDownBtn.addEventListener('click', () => {
    balls.forEach(b => {
      b.dx *= 0.9;
      b.dy *= 0.9;
    });
  });

  // Pause button
  const pauseBtn = document.getElementById('pauseBtn');
  if (pauseBtn) pauseBtn.addEventListener('click', () => {
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
  });

  // Reset button
  const resetBtn = document.getElementById('resetBtn');
  function resetGame() {
    // reset UI
    SQUARE_SIZE = parseInt(blockSizeInput.value, 10) || 10;
    initializeSquares();
    applyColorsToSquares();
    // reset scores
    dayScore = 0;
    nightScore = 0;
    // reset balls to centered positions and default speeds
    balls[0].x = logicalWidth / 4;
    balls[0].y = logicalHeight / 2;
    balls[0].dx = Math.abs(balls[0].dx) || 8;
    balls[0].dy = -(Math.abs(balls[0].dy) || 8);
    balls[0].reverseColor = DAY_COLOR;
    balls[0].ballColor = DAY_BALL_COLOR;

    balls[1].x = (logicalWidth / 4) * 3;
    balls[1].y = logicalHeight / 2;
    balls[1].dx = -(Math.abs(balls[1].dx) || -8);
    balls[1].dy = Math.abs(balls[1].dy) || 8;
    balls[1].reverseColor = NIGHT_COLOR;
    balls[1].ballColor = NIGHT_BALL_COLOR;

    // clear ripples
    ripples.length = 0;
    // unpause
    paused = false;
    if (pauseBtn) pauseBtn.textContent = 'Pause';
  }
  if (resetBtn) resetBtn.addEventListener('click', resetGame);

  // Block size control: update grid size and clamp balls to canvas so they don't disappear
  if (blockSizeInput) blockSizeInput.addEventListener('input', (e) => {
    const newSize = parseInt(e.target.value, 10) || 10;
    const oldSize = SQUARE_SIZE;
    if (newSize === oldSize) return;
    SQUARE_SIZE = newSize;
    initializeSquares();
    applyColorsToSquares();
    // Smoothly reposition balls back into visible bounds over 300ms
    const duration = 300;
    const start = performance.now();
    const starts = balls.map(b => ({ x: b.x, y: b.y }));
    const targets = balls.map(b => ({
      x: Math.min(Math.max(b.x, SQUARE_SIZE / 2), logicalWidth - SQUARE_SIZE / 2),
      y: Math.min(Math.max(b.y, SQUARE_SIZE / 2), logicalHeight - SQUARE_SIZE / 2)
    }));
    function animate() {
      const now = performance.now();
      const t = Math.min(1, (now - start) / duration);
      const e = 1 - Math.pow(1 - t, 3);
      balls.forEach((b, idx) => {
        b.x = starts[idx].x + (targets[idx].x - starts[idx].x) * e;
        b.y = starts[idx].y + (targets[idx].y - starts[idx].y) * e;
      });
      if (t < 1) requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
    // update existing ripples initial radius to new size heuristic
    ripples.forEach(r => {
      r.startR = Math.max(4, SQUARE_SIZE / 2);
      r.maxR = Math.max(24, SQUARE_SIZE * 6);
    });
  });

  // Effects toggle
  const effectsToggle = document.getElementById('effectsToggle');
  if (effectsToggle) effectsToggle.addEventListener('change', (e) => {
    showEffects = !!e.target.checked;
    if (!showEffects) ripples.length = 0;
  });

  // Color pickers
  if (dayColorInput) dayColorInput.addEventListener('input', (e) => {
    DAY_COLOR = e.target.value;
    // keep ball colors contrasting
    DAY_BALL_COLOR = NIGHT_COLOR;
    applyColorsToSquares();
  });
  if (nightColorInput) nightColorInput.addEventListener('input', (e) => {
    NIGHT_COLOR = e.target.value;
    NIGHT_BALL_COLOR = DAY_COLOR;
    applyColorsToSquares();
  });

  // Initialize sizes and grid on load
  // Use a small timeout to allow styles/layout to settle
  window.addEventListener('load', () => resizeCanvas(false));
</script>

</html>